import blanklyimport pandasfrom blankly import StrategyState, Interface, truncfrom blankly.indicators import macdfrom strategies.Ichimoku import Ichimokuimport numpy as npdef init(symbol, state: blankly.StrategyState):    # Download price data for initialization    state.variables['history'] = state.interface.history(symbol, to=300, resolution=state.resolution)    state.variables['owns_position'] = False    state.variables['take_profit'] = 0    state.variables['stop_loss'] = 0    state.variables["count"] = 0    state.variables['leading_span_a'] = np.zeros(len(state.variables['history']), dtype=np.float64)    state.variables['leading_span_b'] = np.zeros(len(state.variables['history']), dtype=np.float64)    # Compute span data for the initial data points    for i in range(26, len(state.variables['history'])):        state.variables['leading_span_a'][i] = ((np.max(state.variables['history'][i - 26:i]) + np.min(            state.variables['history'][i - 26:i])) / 2 + \                                                (np.max(state.variables['history'][i - 9:i]) + np.min(                                                    state.variables['history'][i - 9:i])) / 2) / 2    for i in range(52, len(state.variables['history'])):        state.variables['leading_span_b'][i] = (np.max(state.variables['history'][i - 52:i]) + np.min(            state.variables['history'][i - 52:i])) / 2def price_event(price, symbol, state: blankly.StrategyState):    """ This function will give an updated price every 15 seconds from our definition below """    print(price)    df_dictionary = pandas.DataFrame([price])    state.variables['history'] = pandas.concat([state.variables['history'], df_dictionary], ignore_index=True)    # state.variables['history'].append(price)    print(state.variables["history"])    # exit if we don't have enough populated information yet    if len(state.variables['history']) < 78:        return    conversion = (np.max(state.variables['history'][-9:]) + np.min(state.variables['history'][-9:])) / 2    base = (np.max(state.variables['history'][-26:]) + np.min(state.variables['history'][-26:])) / 2    leading_span_a = (conversion + base) / 2    leading_span_b = (np.max(state.variables['history'][-52:]) + np.min(state.variables['history'][-52:])) / 2    state.variables['leading_span_a'] = np.append(state.variables['leading_span_a'], leading_span_a)    state.variables['leading_span_b'] = np.append(state.variables['leading_span_b'], leading_span_b)    # If we already own a position, look for take profit or stop loss    if state.variables['owns_position']:        if (price <= state.variables['stop_loss'] or price >= state.variables['take_profit']):            # Dollar cost average sell            curr_value = blankly.trunc(state.interface.account[state.base_asset].available, 2)            state.interface.market_order(symbol, side='sell', size=curr_value)            print("\nExiting Long Position ...")            state.variables['owns_position'] = False        return    top_of_cloud_past = max(state.variables['leading_span_a'][-52], state.variables['leading_span_b'][-52])    bottom_of_cloud_past = min(state.variables['leading_span_a'][-52], state.variables['leading_span_b'][-52])    top_of_cloud_current = max(state.variables['leading_span_a'][-26], state.variables['leading_span_b'][-26])    bottom_of_cloud_current = min(state.variables['leading_span_a'][-26], state.variables['leading_span_b'][-26])    cloud_green_in_future = leading_span_a - leading_span_b  # green if positive    # BUY SIGNAL    if (price > top_of_cloud_current) and (conversion > base) and \            (cloud_green_in_future > 0) and (price > top_of_cloud_past):        if not state.variables['owns_position']:            # Buy with full capital            buy = blankly.trunc(state.interface.cash / price, 2)            state.interface.market_order(symbol, side='buy', size=buy)            print("\nEntered Long Position ...")            state.variables['owns_position'] = True            state.variables['stop_loss'] = bottom_of_cloud_current            state.variables['take_profit'] = price + (price - bottom_of_cloud_current) * 1.7if __name__ == "__main__":    exchange = blankly.XTB(portfolio_name="xtb_account")    # Use our strategy helper    strategy = blankly.Strategy(exchange)    # Make the price event function above run every day    # strategy.add_bar_event(Ichimoku.bar_event, symbol='ALI.PL', resolution='1h', init=Ichimoku.init)    strategy.add_bar_event(price_event, symbol='ALI.PL', resolution='1h', init=init)    # Backtest the strategy    results = strategy.backtest(initial_values={'PLN': 5000}, start_date=1568547200, end_date=1647960820)    # strategy.start()    print(results)